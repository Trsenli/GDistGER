##Leveraging embedding vector generated by the skip-gram model
##using the AUC score to evaluate the link prediction task

### Rocman Fang
### 2021.10.1


import argparse
# from gensim.models import Word2Vec
import time
import numpy as np
from sklearn import metrics
import networkx as nx


def parse_args():
    parser = argparse.ArgumentParser(description="Run walk to embedding by SkipGram model.")

    parser.add_argument('--emb', nargs='?', default='./wiki-10.8/vec.txt',#'./wiki-10.8/embedding.out',#
                        help='Embeddings path')

    parser.add_argument('--test_edges', nargs='?', default='./wiki-10.8/Wiki-Vote_LP_test_edges.txt',
                        help='train_graph path')

    parser.add_argument('--test_labels', nargs='?', default='./wiki-10.8/Wiki-Vote_LP_test_labels.txt',
                        help='train_graph path')


    return parser.parse_args()


# def learn_embeddings(walks):
#     '''
#     Learn embeddings by optimizing the Skipgram objective using SGD.
#     '''
#     walks = [map(str, walk) for walk in walks]
#     model = Word2Vec(walks, size=args.dimensions, window=args.window_size, min_count=0, sg=1, workers=args.workers,
#                      iter=args.iter)
#     model.wv.save_word2vec_format(args.output)

#     return model.wv


def readwalks(walk_file):

    walks = []

    with open(walk_file, 'r') as f:
        for path in f.readlines():
            path = path.strip('\n')
            path = path.strip()
            path = path.split(" ")
            walk = []
            for elm in path:

                walk.append(int(elm))

            walks.append(walk)

    f.close()
    return walks

def evaluateStaticLinkPrediction(wv, test_edges, test_labels):

    n_tot = len((test_edges))
    # print (n_tot)
    feature_vec = np.empty(n_tot, dtype='f')
    for ii in range(n_tot):
        # print (ii)
        v1, v2 = test_edges[ii]

        feature_vec[ii] = np.dot(wv[str(v1)], wv[str(v2)])
    AUC = metrics.roc_auc_score(test_labels,feature_vec)
    return AUC

def str_list_to_float(str_list):
    return [float(item) for item in str_list]


def read_emb(emb_file):
    with open(emb_file, "r") as f:
        lines = f.readlines()
        emb_ind = lines[0].split()
        lines_emb = lines[1:]

        # emb_vec = np.random.rand(int(emb_ind[0]), int(emb_ind[1]))
        emb_vec = {}

        for line in lines_emb:
            # print (j)
            emd = line.split()
            emb_vec[str(emd[0])] = str_list_to_float(emd[1:])

    return emb_vec

def read_emb1(emb_file):

    nodes_lis = list(range(0, 7115))

    emb_file = open(emb_file, 'r')
    emb_vec = {}
    j = 0
    for emb in emb_file.readlines():
        emd_line = emb.split()

        emb_vec[str(nodes_lis[j])] = str_list_to_float(emd_line)

        j = j + 1

    return emb_vec

def main(args):

    # emb_vec = read_emb1(args.emb) ####fast_node2vec
    emb_vec = read_emb(args.emb) ####google word2vec

    print('AUC computing:')
    t2 = time.time()

    test_edges = []
    with open(args.test_edges, "r") as ff:

        test_edges_list = ff.readlines()

        for edge in test_edges_list:
            edge_sp = edge.split()
            test_edges.append((int(edge_sp[0]), int(edge_sp[1])))

    test_labels = []

    with open(args.test_labels, "r") as ff:
        label_list = ff.readlines()
        for label in label_list:
            label = label[0].split()
            test_labels.append(int(label[0]))

    AUC = evaluateStaticLinkPrediction(emb_vec, test_edges, test_labels)

    print("AUC: %f" % AUC)
    print("AUC time used:", time.time()-t2, "s")

if __name__ == "__main__":
    args = parse_args()
    main(args)